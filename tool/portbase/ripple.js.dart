import 'dart:html' as html;
import 'dart:math' as Math;

/// license
/// Copyright 2015 Google Inc. All Rights Reserved.
/// 
/// Licensed under the Apache License, Version 2.0 (the "License");
/// you may not use this file except in compliance with the License.
/// You may obtain a copy of the License at
/// 
/// http://www.apache.org/licenses/LICENSE-2.0
/// 
/// Unless required by applicable law or agreed to in writing, software
/// distributed under the License is distributed on an "AS IS" BASIS,
/// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
/// See the License for the specific language governing permissions and
/// limitations under the License.

( /*function*/ () {

/// Class constructor for Ripple MDL component.
/// Implements MDL component design pattern defined at:
/// https://github.com/jasonmayes/mdl-component-design-pattern
/// 
/// constructor
/// param {HTMLElement} element The element that will be upgraded.

  final MaterialRipple = function MaterialRipple(element) {

    // Initialize instance.
    init();
  }
  window['MaterialRipple'] = MaterialRipple;

/// Store constants in one place so they can be updated easily.
/// 
/// enum {string | number}
class _  MaterialRippleConstant {
      final String INITIAL_SCALE = 'scale(0.0001, 0.0001)';
      final String INITIAL_SIZE = '1px';
      final String INITIAL_OPACITY = '0.4';
      final String FINAL_OPACITY = '0';
    FINAL_SCALE: ''
  }

/// Store strings for class names defined by this component that are used in
/// JavaScript. This allows us to simply change it in one place should we
/// decide to modify at a later date.
/// 
/// enum {string}
class _  MaterialRippleCssClasses {
      final String RIPPLE_CENTER = 'mdl-ripple--center';
      final String RIPPLE_EFFECT_IGNORE_EVENTS = 'mdl-js-ripple-effect--ignore-events';
      final String RIPPLE = 'mdl-ripple';
      final String IS_ANIMATING = 'is-animating';
      final String IS_VISIBLE = 'is-visible';
  }

/// Handle mouse / finger down on element.
/// 
/// param {Event} event The event that fired.
///   MaterialRipple.prototype.downHandler_ = function(event) {
void _downHandler(final html.Event event) {
    if (!_rippleElement.style.width && !_rippleElement.style.height) {

      final rect = element.getBoundingClientRect();
      boundHeight = rect.height;
      boundWidth = rect.width;
      _rippleSize = Math.sqrt(rect.width * rect.width +
          rect.height * rect.height) * 2 + 2;
      _rippleElement.style.width = _rippleSize + 'px';
      _rippleElement.style.height = _rippleSize + 'px';
    }

    _rippleElement.classes.add(_cssClasses.IS_VISIBLE);

    if (event.type == 'mousedown' && _ignoringMouseDown) {
      _ignoringMouseDown = false;

    } else {
      if (event.type == 'touchstart') {
        _ignoringMouseDown = true;
      }

      final frameCount = getFrameCount();
      if (frameCount > 0) {
        return;
      }
      setFrameCount(1);

      final bound = event.currentTarget.getBoundingClientRect();

      final x;

      final y;
      // Check if we are handling a keyboard click.
      if (event.clientX == 0 && event.clientY == 0) {
        x = Math.round(bound.width / 2);
        y = Math.round(bound.height / 2);

      } else {

        final clientX = event.clientX ? event.clientX : event.touches[0].clientX;

        final clientY = event.clientY ? event.clientY : event.touches[0].clientY;
        x = Math.round(clientX - bound.left);
        y = Math.round(clientY - bound.top);
      }
      setRippleXY(x, y);
      setRippleStyles(true);
      window.requestAnimationFrame(animFrameHandler);
    }
  }

/// Handle mouse / finger up on element.
/// 
/// param {Event} event The event that fired.
///   MaterialRipple.prototype.upHandler_ = function(event) {
void _upHandler(final html.Event event) {
    // Don't fire for the artificial "mouseup" generated by a double-click.
    if (event && event.detail != 2) {
      _rippleElement.classes.remove(_cssClasses.IS_VISIBLE);
    }
    // Allow a repaint to occur before removing this class, so the animation
    // shows for tap events, which seem to trigger a mouseup too soon after
    // mousedown.
    window.setTimeout( /*function*/ () {
      _rippleElement.classes.remove(_cssClasses.IS_VISIBLE);
    }, 0);
  }

/// Initialize element.
///   MaterialRipple.prototype.init = /*function*/ () {
void init() {
    if (element != null) {

      final recentering =
          element.classes.contains(_cssClasses.RIPPLE_CENTER);
      if (!element.classes.contains(
          _cssClasses.RIPPLE_EFFECT_IGNORE_EVENTS)) {
        _rippleElement = element.querySelector('.' +
            _cssClasses.RIPPLE);
        _frameCount = 0;
        _rippleSize = 0;
        _x = 0;
        _y = 0;

        // Touch start produces a compat mouse down event, which would cause a
        // second ripples. To avoid that, we use this property to ignore the first
        // mouse down after a touch start.
        _ignoringMouseDown = false;

        _boundDownHandler = downHandler;
        element.addEventListener('mousedown',
          boundDownHandler);
        element.addEventListener('touchstart',
            boundDownHandler);

        _boundUpHandler = upHandler;

	// .addEventListener('mouseup', -- .onMouseUp.listen(<MouseEvent>);
        element.onMouseUp.listen( boundUpHandler);

	// .addEventListener('mouseleave', -- .onMouseLeave.listen(<MouseEvent>);
        element.onMouseLeave.listen( boundUpHandler);
        element.addEventListener('touchend', boundUpHandler);

	// .addEventListener('blur', -- .onBlur.listen(<Event>);
        element.onBlur.listen( boundUpHandler);

/// Getter for frameCount_.
/// return {number} the frame count.
        getFrameCount = /*function*/ () {
          return _frameCount;
        }

/// Setter for frameCount_.
/// param {number} fC the frame count.
        setFrameCount = function(fC) {
          _frameCount = fC;
        }

/// Getter for rippleElement_.
/// return {Element} the ripple element.
        getRippleElement = /*function*/ () {
          return _rippleElement;
        }

/// Sets the ripple X and Y coordinates.
/// param  {number} newX the new X coordinate
/// param  {number} newY the new Y coordinate
        setRippleXY = function(newX, newY) {
          _x = newX;
          _y = newY;
        }

/// Sets the ripple styles.
/// param  {boolean} start whether or not this is the start frame.
        setRippleStyles = function(start) {
          if (_rippleElement != null) {

            final transformString;

            final scale;

            final size;

            final offset = 'translate(' + _x + 'px, ' + _y + 'px)';

            if (start) {
              scale = _constant.INITIAL_SCALE;
              size = _constant.INITIAL_SIZE;

            } else {
              scale = _constant.FINAL_SCALE;
              size = _rippleSize + 'px';
              if (recentering) {
                offset = 'translate(' + boundWidth / 2 + 'px, ' +
                  boundHeight / 2 + 'px)';
              }
            }

            transformString = 'translate(-50%, -50%) ' + offset + scale;

            _rippleElement.style.webkitTransform = transformString;
            _rippleElement.style.msTransform = transformString;
            _rippleElement.style.transform = transformString;

            if (start) {
              _rippleElement.classes.remove(_cssClasses.IS_ANIMATING);

            } else {
              _rippleElement.classes.add(_cssClasses.IS_ANIMATING);
            }
          }
        }

/// Handles an animation frame.
        animFrameHandler = /*function*/ () {
          if (_frameCount-- > 0) {
            window.requestAnimationFrame(animFrameHandler);

          } else {
            setRippleStyles(false);
          }
        }
      }
    }
  }

/// Downgrade the component
/// 
///   MaterialRipple.prototype.mdlDowngrade_ = /*function*/ () {
void _mdlDowngrade() {
    element.removeEventListener('mousedown',
    boundDownHandler);
    element.removeEventListener('touchstart',
        boundDownHandler);

    element.removeEventListener('mouseup', boundUpHandler);
    element.removeEventListener('mouseleave', boundUpHandler);
    element.removeEventListener('touchend', boundUpHandler);
    element.removeEventListener('blur', boundUpHandler);
  }

/// Public alias for the downgrade method.
/// 
/// public
  MaterialRipple.prototype.mdlDowngrade =
      MaterialRipple.prototype.mdlDowngrade_;

  MaterialRipple.prototype['mdlDowngrade'] =
      MaterialRipple.prototype.mdlDowngrade;

  // The component registers itself. It can assume componentHandler is available
//   // in the global scope.

//   componentHandler.register({
//     constructor: MaterialRipple,
//     classAsString: 'MaterialRipple',
//     cssClass: 'mdl-js-ripple-effect',
//     widget: false
//   });
// })();
